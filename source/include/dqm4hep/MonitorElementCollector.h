/*
 *
 * DQMMonitorElementCollector.h header template automatically generated by a class generator
 * Creation date : ven. mai 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef DQM4HEP_MONITORELEMENTCOLLECTOR_H
#define DQM4HEP_MONITORELEMENTCOLLECTOR_H

// -- dqm4hep headers
#include "dqm4hep/Internal.h"
#include "dqm4hep/StatusCodes.h"
#include "dqm4hep/Application.h"
#include "dqm4hep/OnlineElement.h"

// -- tclap headers
#include "tclap/CmdLine.h"
#include "tclap/Arg.h"

namespace dqm4hep {

  namespace online {
    
    class CollectorData {
    public:
      CollectorData() = default;
      ~CollectorData();
      void set(OnlineElementPtr monitorElement);
      core::Signal<CollectorData*> &onRemove();
      core::Signal<CollectorData*> &onReplace();
      
    private:
      OnlineElementPtr                m_monitorElement = {nullptr};
      core::Signal<CollectorData*>    m_removedSignal = {};
      core::Signal<CollectorData*>    m_replacedSignal = {};
    };
    
    class ElementSubscriber {
    public:
      ElementSubscriber(int clientId);
    private:
    };
    
    class CollectorStorage {
    public:
      CollectorStorage() = default;
      
      void addMonitorElement(const std::string &source, OnlineElementPtr monitorElement);
      bool addSubscription(const std::string &source, const std::string &path, const std::string &name, int clientID);
      void removeSubscription(const std::string &source, const std::string &path, const std::string &name, int clientID);
      void removeSubscription(int clientID);
      OnlineElementPtr getMonitorElement(const std::string &source, const std::string &path, const std::string &name) const;
      OnlineElementPtrList getSubscribedElements(const std::string &source);
      OnlineElementPtrList getSubscribedElements(const std::string &source, int clientID);
      void clear(const std::string &source);
      void clear();
    private:
      using OnlineElementPtrSet = std::set<OnlineElementPtr>;
      using MonitorElementInfoMap = std::map<std::string, OnlineElementPtrSet>;
      using SubscriberMap = std::map<int, MonitorElementInfoMap>;
      
    private:
      core::Signal<OnlineElementPtr>       m_removeElementSignal;
      core::Signal<OnlineElementPtr>       m_newElementSignal;
      MonitorElementInfoMap          m_monitorElementInfoMap;
      SubscriberMap                  m_subscriberMap;
    };
    
    /**
     *  @brief  MonitorElementCollector class
     */
    class MonitorElementCollector : public Application {
    public:
      MonitorElementCollector() = default;
      MonitorElementCollector(const MonitorElementCollector&) = delete;
      MonitorElementCollector& operator=(const MonitorElementCollector&) = delete;
      
      /**
       *  @brief  Destructor
       */
      ~MonitorElementCollector();
      
    private:
      void parseCmdLine(int argc, char **argv) override;
      void onInit() override;
      void onEvent(AppEvent *pAppEvent) override;
      void onStart() override;
      void onStop() override;
      
      void handleRegistration(const net::Buffer &request, net::Buffer &response);
      void handleClientUnregistration(const net::Buffer &/*buffer*/);
      void handleClientExit(StoreEvent<int> *event);
      void handleCollectElements(const net::Buffer &buffer);
      
    private:
      struct MeInfo {
        std::string         m_path = {""};
        std::string         m_name = {""};
      };
      using MeInfoList = std::vector<MeInfo>;
      
      struct SourceInfo {
        int                        m_clientId = {0};
        std::string                m_sourceName = {""};
        MeInfoList                 m_availableElements = {};
      };
      using SourceInfoMap = std::map<std::string, SourceInfo>;
      
    private:
      /// The command line utility to parse cmd line
      std::shared_ptr<TCLAP::CmdLine>     m_cmdLine = {nullptr};
      /// 
      SourceInfoMap                       m_sourceInfoMap = {};
    };
    
  }
  
}


// namespace dqm4hep {
// 
//   namespace core {
// 
//     class MonitorElementCollector;
//     class Storage;
// 
//     /** ModuleMeInfo class
//      */
//     class ModuleMeInfo
//     {
//     private:
//       /** MeInfo struct
//        */
//       struct MeInfo
//       {
//         std::set<int>         m_clientList;
//         MonitorElementPtr  m_monitorElement;
//       };
//       typedef std::map<std::string,  MeInfo *> MeInfoMap;
// 
//     public:
//       /** Constructor
//        */
//       ModuleMeInfo();
// 
//       /** Destructor
//        */
//       ~ModuleMeInfo();
// 
//       /** Set the list of monitor element available on the module application
//        */
//       void setAvailableMeList(const MonitorElementInfoList &meNameList);
// 
//       /** Get the list of monitor element available on the module application
//        */
//       const MonitorElementInfoList &getAvailableMeList() const;
// 
//       /** Update the monitor element entry.
//        *  Return whether the monitor element was updated
//        */
//       bool updateMonitorElement(MonitorElementPtr &monitorElement);
// 
//       /** Get a specific monitor element.
//        *  Return NULL is the entry doesn't exists
//        */
//       MonitorElementPtr getMonitorElement(const std::string &meName, bool partialCompare = false, bool lowerCaseCompare = false) const;
// 
//       /** Get the subscribed me name list. Simply iterate over stored monitor element
//        *  and add the element to list if a client has subscribed to it
//        */
//       StringSet getSubscribedList() const;
// 
//       /** Get the subscribed me name list for a particular client
//        */
//       StringSet getSubscribedList(int clientID) const;
// 
//       /** Get the subscribed me list for a particular client
//        */
//       MonitorElementPtrList getSubscribedMeList(int clientID) const;
// 
//       /** Subscribe client to a monitor element.
//        *
//        *  Return a pair :
//        *    * first -> the new size of the subscriber clients
//        *    * second -> whether the client was inserted in the subscriber list
//        */
//       std::pair<size_t, bool> subscribe(int clientID, const std::string &meName);
// 
//       /** Un-subscribe client from a monitor element.
//        *
//        *  Return a pair :
//        *    * first -> the new size of the subscriber clients
//        *    * second -> whether the client was erased from the subscriber list
//        */
//       std::pair<size_t, bool> unsubscribe(int clientID, const std::string &meName);
// 
//       /** Unsubscribe all the elements for this client.
//        *  Return true if the client at least unsubscribe to one element
//        */
//       bool unsubscribe(int clientID);
// 
//       /** Get the number of clients that have subscribe from a particular a monitor element
//        */
//       size_t getNSubscribers(const std::string &meName) const;
// 
//       /** Get the number of clients that have subscribes to this module
//        */
//       size_t getNSubscribers() const;
// 
//       /** Get the list of subscribers for a particular monitor element
//        */
//       std::set<int> getSubscribers(const std::string &meName) const;
// 
//     private:
//       MonitorElementInfoList                          m_availableMeList;
//       StringSet                                          m_requestedMeList;
//       MeInfoMap                                          m_meInfoMap;
//     };
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     /** ClientInfo class
//      */
//     class ClientInfo
//     {
//     public:
//       /** Constructor for monitor element clients
//        */
//       ClientInfo(int clientID);
// 
//       /** Constructor for module clients
//        */
//       ClientInfo(int clientId, const std::string &moduleName);
// 
//       /** Get the module name.
//        *  Valid only if the client is a module.
//        */
//       const std::string &getModuleName() const;
// 
//       /** Whether the client is a module.
//        *  Opposite is a monitor element client
//        */
//       bool isModule() const;
// 
//       /** Get the client id
//        */
//       int getClientID() const;
// 
//       /** Set update mode (default is false)
//        */
//       void setUpdateMode(bool update);
// 
//       /** Whether the client works in update mode
//        */
//       bool hasUpdateMode() const;
// 
//     private:
//       int                  m_clientID;
//       bool                 m_updateMode;
//       bool                 m_isModule;
//       std::string          m_moduleName;
//     };
// 
//     typedef std::map<int, ClientInfo>  ClientMap;
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     class MonitorElementNameListRpc : public DimRpc
//     {
//     public:
//       MonitorElementNameListRpc(char *rpcName, MonitorElementCollector *pCollector);
//       void rpcHandler();
// 
//     private:
//       MonitorElementCollector   *m_pCollector;
//     };
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     class MonitorElementCollectorInfoRpc : public DimRpc
//     {
//     public:
//       MonitorElementCollectorInfoRpc(char *rpcName, MonitorElementCollector *pCollector);
//       void rpcHandler();
// 
//     private:
//       MonitorElementCollector   *m_pCollector;
//     };
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     /** MonitorElementCollector class
//      */
//     class MonitorElementCollector : public DimServer
//     {
//     public:
//       /** Constructor
//        */
//       MonitorElementCollector();
// 
//       /** Destructor
//        */
//       ~MonitorElementCollector();
// 
//       /** Set the collector name. Can be set only if the collector is not running.
//        *  The collector name is used to build the service and command names over the network
//        */
//       StatusCode setCollectorName(const std::string &collectorName);
// 
//       /** Get the collector name
//        */
//       const std::string &getCollectorName() const;
// 
//       /** Start the collector. Allocate services and commands
//        */
//       StatusCode start();
// 
//       /** Stop the collector. Destroy the commands and services
//        */
//       StatusCode stop();
// 
//       /** Get the collector state. See State enum (DQM4HEP.h)
//        */
//       State getState() const;
// 
//       /** Whether the collector is running
//        */
//       bool isRunning() const;
// 
//     public:
//       typedef std::map<std::string, ModuleMeInfo *>             ModuleMeInfoMap;  ///< Module element storage
//       typedef std::set<MonitorElementPtr>                    MonitorElementPtrSet;
//       typedef std::map<int, MonitorElementPtrSet>            ClientUpdateMap;  ///< Map of monitor element list to update
// 
//       static const std::string         m_emptyBufferStr;
// 
//     private:
//       /** Dim command handler
//        */
//       void commandHandler();
// 
//       /** Dim client exit handler
//        */
//       void clientExitHandler();
// 
// 
//       /** Update client side with the monitor elements
//        */
//       void updateClients(const ClientUpdateMap &clientUpdateMap, bool forceUpdate = false);
// 
//       /** Handle the monitor element packet reception from a module application
//        */
//       void handleMeCollectUpdate(DimCommand *pCommand);
// 
//       /** Handle the available list of monitor element on module side
//        */
//       void handleAvailableListUpdate(DimCommand *pCommand);
// 
//       /** Handle a client subscription
//        */
//       void handleClientSubscription(int clientID, DimCommand *pCommand);
// 
//       /** Handle a client unsubscription
//        */
//       void handleClientUnsubscription(int clientID, DimCommand *pCommand);
// 
//       /** Handle client automatic update mode
//        */
//       void handleClientUpdateMode(int clientId, bool updateMode);
// 
//       /** Handle client me name request list update
//        */
//       void handleClientRequestList(int clientId, DimCommand *pCommand);
// 
//       /** Handle the me query of target client id
//        */
//       void handleMeQuery(int clientId, DimCommand *pCommand);
// 
//       /** Update the monitor element publication service for a specific client
//        */
//       void sendMeUpdate(int clientID);
// 
//       /** Notify the module that users are watching a different set of
//        *  monitor elements provided by the module
//        */
//       void notifyWatchedMe(const std::string &moduleName);
// 
//       /** Register a monitor element client
//        */
//       bool registerClient(int clientId);
// 
//       /** Register a module client
//        */
//       bool registerClient(int clientId, const std::string moduleName);
// 
//       /** De-register a client
//        */
//       bool deregisterClient(int clientId);
// 
//       /** Get the module client ID.
//        *  Return 0 is not found (invalid for dim)
//        */
//       int getModuleClientID(const std::string &moduleName) const;
// 
//       /**
//        */
//       void configureInBuffer( char *pBuffer , uint32_t bufferSize );
// 
//     private:
//       // collector name
//       std::string                        m_collectorName;
// 
//       // dim related
//       MonitorElementNameListRpc         *m_pMonitorElementNameListRpc;
//       MonitorElementCollectorInfoRpc    *m_pMonitorElementCollectorInfoRpc;
// 
//       DimCommand                        *m_pCollectMeCommand;
//       DimCommand                        *m_pAvailableMeListCommand;
//       DimCommand                        *m_pMeQueryCommand;
//       DimCommand                        *m_pSetUpdateModeCommand;
//       DimCommand                        *m_pSubscribeCommand;
//       DimCommand                        *m_pUnsubscribeCommand;
//       DimCommand                        *m_pSetSubscriptionCommand;
//       DimCommand                        *m_pQuerySubscribedCommand;
// 
//       DimService                        *m_pMeUpdateService;
//       DimService                        *m_pNotifyWatchedMeService;
//       DimService                        *m_pCollectorStateService;
//       DimService                        *m_pAvailableMeService;
//       StatisticsService                 *m_pStatisticsService;
// 
//       // runtime
//       int                                m_collectorState;
//       xdrstream::BufferDevice           *m_pInBuffer;
//       xdrstream::BufferDevice           *m_pOutBuffer;
// 
//       // clients and storage
//       ModuleMeInfoMap                    m_moduleMeInfoMap;
//       ClientMap                          m_clientMap;
// 
//       friend class CollectorCommandHandler;
//       friend class MonitorElementNameListRpc;
//       friend class MonitorElementCollectorInfoRpc;
//     };
// 
//   }
// 
// }

#endif  //  DQM4HEP_MONITORELEMENTCOLLECTOR_H
