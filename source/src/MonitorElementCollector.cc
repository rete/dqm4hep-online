/*
 *
 * DQMMonitorElementCollector.cc source template automatically generated by a class generator
 * Creation date : ven. mai 8 2015
 *
 * This file is part of DQM4HEP libraries.
 * 
 * DQM4HEP is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * DQM4HEP is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with DQM4HEP.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- dqm4hep headers
#include "dqm4hep/MonitorElementCollector.h"
#include "dqm4hep/QualityTest.h"
#include "dqm4hep/MonitorElementStreamer.h"
#include "dqm4hep/OnlineElement.h"
#include "dqm4hep/Logging.h"
#include "dqm4hep/OnlineRoutes.h"
#include "DQMOnlineConfig.h"

namespace dqm4hep {
  
  namespace online {
    
    CollectorData::~CollectorData() {
      m_removedSignal.process(this);
    }
    
    void CollectorData::set(OnlineElementPtr monitorElement) {
      const bool emitSignal(nullptr != m_monitorElement);
      m_monitorElement = monitorElement;
      if(emitSignal) {
        m_replacedSignal.process(this);
      }
    }
    
    core::Signal<CollectorData*> &CollectorData::onRemove() {
      return m_removedSignal;
    }
    
    core::Signal<CollectorData*> &CollectorData::onReplace() {
      return m_replacedSignal;
    }
    
        
    void CollectorStorage::addMonitorElement(const std::string &source, OnlineElementPtr monitorElement) {
      auto findIter = m_monitorElementInfoMap.find(source);
      if(m_monitorElementInfoMap.end() == findIter) {
        findIter = m_monitorElementInfoMap.insert(MonitorElementInfoMap::value_type(source, MonitorElementInfoMap::mapped_type())).first;
      }
      
    }
    
    //-------------------------------------------------------------------------------------------------
    
    bool CollectorStorage::addSubscription(const std::string &source, const std::string &path, const std::string &name, int clientID) {
      auto findIter = m_subscriberMap.find(clientID);
      if(m_subscriberMap.end() == findIter) {
        findIter = m_subscriberMap.insert(SubscriberMap::value_type(clientID, MonitorElementInfoMap())).second;
      }
      auto monitorElement = getMonitorElement(source, path, name);
      if(nullptr == monitorElement) {
        return false;
      }
      findIter->second[source].insert(monitorElement);
      return true;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void CollectorStorage::removeSubscription(const std::string &source, const std::string &path, const std::string &name, int clientID) {
      auto findIter = m_subscriberMap.find(clientID);
      if(m_subscriberMap.end() == findIter) {
        return;
      }
      auto findIter2 = findIter->second.find(source);
      if(findIter->second.end() == findIter2) {
        return;
      }
      for(auto iter = findIter2->second.begin() ; iter != findIter2->second.end() ; ++iter) {
        if(iter->path() == path and iter->name() == name) {
          findIter2->erase(iter);
          break;
        }
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void CollectorStorage::removeSubscription(int clientID) {
      for(auto &sourceIter : m_monitorElementInfoMap) {
        for(auto &elt : sourceIter.second) {
          elt.m_subscribers.erase(clientID);
        }
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    OnlineElementPtr CollectorStorage::getMonitorElement(const std::string &source, const std::string &path, const std::string &name) const {
      auto findIter = m_monitorElementInfoMap.find(source);
      if(m_monitorElementInfoMap.end() == findIter) {
        return nullptr;
      }
      for(auto &elt : findIter->second) {
        if(nullptr == elt.m_monitorElement) {
          continue;
        }
        if(elt.m_monitorElement->path() == path and elt.m_monitorElement->name() == name) {
          return elt.m_monitorElement;
        }
      }
      return nullptr;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    OnlineElementPtrList CollectorStorage::getSubscribedElements(const std::string &source) {
      OnlineElementPtrList list;
      auto findIter = m_monitorElementInfoMap.find(source);
      if(m_monitorElementInfoMap.end() == findIter) {
        return list;
      }
      for(auto &elt : findIter->second) {
        if(not elt.m_subscribers.empty()) {
          list.push_back(elt.m_monitorElement);
        }
      }
      return list;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    OnlineElementPtrList CollectorStorage::getSubscribedElements(const std::string &source, int clientID) {
      OnlineElementPtrList list;
      auto findIter = m_monitorElementInfoMap.find(source);
      if(m_monitorElementInfoMap.end() == findIter) {
        return list;
      }
      for(auto &elt : findIter->second) {
        if(0 != elt.m_subscribers.find(clientID)) {
          list.push_back(elt.m_monitorElement);
        }
      }
      return list;
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void CollectorStorage::clear(const std::string &source) {
      auto findIter = m_monitorElementInfoMap.find(source);
      if(m_monitorElementInfoMap.end() != findIter) {
        findIter->second.clear();
      }
      // for()
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void CollectorStorage::clear() {
      m_monitorElementInfoMap.clear();
      m_subscriberMap.clear();
    }
  
    //-------------------------------------------------------------------------------------------------
    //-------------------------------------------------------------------------------------------------
  
    MonitorElementCollector::~MonitorElementCollector() {
      
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::parseCmdLine(int argc, char **argv) {
      std::string cmdLineFooter = "Please report bug to <dqm4hep@gmail.com>";
      m_cmdLine = std::make_shared<TCLAP::CmdLine>(cmdLineFooter, ' ', DQMOnline_VERSION_STR);
      
      TCLAP::ValueArg<std::string> collectorNameArg(
          "c"
          , "collector-name"
          , "The monitor element collector name"
          , true
          , ""
          , "string");
      m_cmdLine->add(collectorNameArg);
      
      core::StringVector verbosities(core::Logger::logLevels());
      TCLAP::ValuesConstraint<std::string> verbosityConstraint(verbosities);
      TCLAP::ValueArg<std::string> verbosityArg(
          "v"
          , "verbosity"
          , "The logging verbosity"
          , false
          , "info"
          , &verbosityConstraint);
      m_cmdLine->add(verbosityArg);
      
      // parse command line
      m_cmdLine->parse(argc, argv);

      std::string verbosity(verbosityArg.getValue());
      std::string collectorName(collectorNameArg.getValue());
      setType(OnlineRoutes::MonitorElementCollector::applicationType());
      setName(collectorName);
      setLogLevel(core::Logger::logLevelFromString(verbosity));
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::onInit() {
      // create network services
      createRequestHandler(
        OnlineRoutes::MonitorElementCollector::registerSource(name()), 
        this, 
        &MonitorElementCollector::handleRegistration
      );
      createDirectCommand(
        OnlineRoutes::EventCollector::unregisterSource(name()), 
        this, 
        &MonitorElementCollector::handleClientUnregistration
      );
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::onEvent(AppEvent * /*pAppEvent*/) {
      
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::onStart() {
      
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::onStop() {
      
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::handleRegistration(const net::Buffer &request, net::Buffer &response) {
      core::json registrationDetails({});
      if(0 != request.size()) {
        registrationDetails = core::json::parse(request.begin(), request.end());   
      }
      auto sourceName = registrationDetails.value<std::string>("source", "");
      auto clientId = this->serverClientId();
      auto findIter = m_sourceInfoMap.find(sourceName);
      core::json clientResponseValue({});
      
      // source already registered
      if(m_sourceInfoMap.end() != findIter) {
        if(clientId == findIter->second.m_clientId) {
          clientResponseValue["message"] = "Monitor element source already registered !";
          clientResponseValue["registered"] = true;
        }
        else {
          std::stringstream ss; ss << "Monitor element source already registered with a different client ID (" << findIter->second.m_clientId << ") !";
          clientResponseValue["message"] = ss.str();
          clientResponseValue["registered"] = false;
        }
      }
      else {
        SourceInfo sourceInfo;
        findIter->second.m_clientId = clientId;
        findIter->second.m_sourceName = sourceName;
        auto availableElements = registrationDetails.value<core::json>("available", {});
        for(auto iter = availableElements.begin() ; iter != availableElements.end() ; ++iter) {
          MeInfo info;
          info.m_path = (*iter).value("path", "");
          info.m_name = (*iter).value("name", "");
          findIter->second.m_availableElements.push_back(info);
        }
        dqm_info( "New monitor element source '{0}' registered with client id {1}", findIter->second.m_sourceName, findIter->second.m_clientId );
        clientResponseValue["registered"] = true;
      }
      auto model = response.createModel<std::string>();
      model->copy(clientResponseValue.dump());
      response.setModel(model);
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::handleClientUnregistration(const net::Buffer &/*buffer*/) {
      const int clientId(serverClientId());
      auto findIter = std::find_if(m_sourceInfoMap.begin(), m_sourceInfoMap.end(), [&clientId](const SourceInfoMap::value_type &iter){
        return (iter.second.m_clientId == clientId);
      });
      
      if(findIter != m_sourceInfoMap.end()) {
        dqm_info( "Removing source '{0}' from source list !", findIter->second.m_sourceName );
        m_sourceInfoMap.erase(findIter);
        // sendStat("NSources", m_sourceInfoMap.size());
      }
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::handleClientExit(StoreEvent<int> *event) {
      const int clientId(event->data());
      auto findIter = std::find_if(m_sourceInfoMap.begin(), m_sourceInfoMap.end(), [&clientId](const SourceInfoMap::value_type &iter){
        return (iter.second.m_clientId == clientId);
      });
      if(findIter != m_sourceInfoMap.end()) {
        dqm_info( "Removing source '{0}' from source list !", findIter->second.m_sourceName );
        m_sourceInfoMap.erase(findIter);
        // sendStat("NSources", m_sourceInfoMap.size());
      }
      // TODO look in monitor element client list
      // and do the same
    }
    
    //-------------------------------------------------------------------------------------------------
    
    void MonitorElementCollector::handleCollectElements(const net::Buffer &buffer) {
      const int clientId(serverClientId());
      auto findIter = std::find_if(m_sourceInfoMap.begin(), m_sourceInfoMap.end(), [&clientId](const SourceInfoMap::value_type &iter){
        return (iter.second.m_clientId == clientId);
      });
      if(findIter != m_sourceInfoMap.end()) {
        xdrstream::BufferDevice device((char*)buffer.begin(), buffer.size(), false);
        core::MonitorElementStreamer streamer;
        OnlineElementPtrList monitorElementList;
        auto readStatus = streamer.readMonitorElements(monitorElementList, &device);
        if(readStatus != core::STATUS_CODE_SUCCESS) {
          dqm_warning( "Couldn't collect monitor elements for source '{0}', read buffer error !", findIter->second.m_sourceName );
          return;
        }
      }
    }
        
  }
  
}



// namespace dqm4hep {
// 
//   namespace core {
// 
//     static const char pMeCollectormptyBuffer [] = "EMPTY";
// 
//     ModuleMeInfo::ModuleMeInfo()
//     {
//       /* nop */
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     ModuleMeInfo::~ModuleMeInfo()
//     {
//       for(MeInfoMap::iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//         delete iter->second;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void ModuleMeInfo::setAvailableMeList(const MonitorElementInfoList &meNameList)
//     {
//       m_availableMeList = meNameList;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     const MonitorElementInfoList &ModuleMeInfo::getAvailableMeList() const
//     {
//       return m_availableMeList;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool ModuleMeInfo::updateMonitorElement(MonitorElementPtr &monitorElement)
//     {
//       if(NULL == monitorElement)
//         return false;
// 
//       // full name = path + name
//       std::string fullName = (monitorElement->getPath() + monitorElement->getName()).getPath();
// 
//       if(fullName.at(0) != '/')
//         fullName = "/" + fullName;
// 
//       // look for an existing entry
//       MeInfoMap::iterator findIter = m_meInfoMap.find(fullName);
// 
//       if(findIter == m_meInfoMap.end())
//       {
//         MeInfo *pMeInfo = new MeInfo();
//         std::pair<MeInfoMap::iterator, bool> ret = m_meInfoMap.insert(MeInfoMap::value_type(fullName, pMeInfo));
// 
//         if(!ret.second)
//         {
//           delete pMeInfo;
//           return false;
//         }
// 
//         findIter = ret.first;
//       }
// 
//       // replace it !
//       findIter->second->m_monitorElement = monitorElement;
// 
//       return true;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     MonitorElementPtr ModuleMeInfo::getMonitorElement(const std::string &meName, bool partialCompare, bool lowerCaseCompare) const
//     {
//       std::string elementNameToCompare = meName;
// 
//       if(lowerCaseCompare)
//         std::transform(elementNameToCompare.begin(), elementNameToCompare.end(), elementNameToCompare.begin(), ::tolower);
// 
//       for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         std::string elementName = iter->first;
// 
//         if(lowerCaseCompare)
//           std::transform(elementName.begin(), elementName.end(), elementName.begin(), ::tolower);
// 
//         if(partialCompare)
//         {
//           if(elementName.find(elementNameToCompare) == std::string::npos)
//             continue;
//         }
//         else
//         {
//           if(elementName != elementNameToCompare)
//             continue;
//         }
// 
//         return iter->second->m_monitorElement;
//       }
// 
//       return MonitorElementPtr();
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     StringSet ModuleMeInfo::getSubscribedList() const
//     {
//       StringSet requestedMeList;
// 
//       for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         if( ! iter->second->m_clientList.empty() )
//           requestedMeList.insert( iter->first );
//       }
// 
//       return requestedMeList;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     StringSet ModuleMeInfo::getSubscribedList(int clientID) const
//     {
//       StringSet requestedMeList;
// 
//       for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         if( iter->second->m_clientList.find(clientID) != iter->second->m_clientList.end() )
//           requestedMeList.insert( iter->first );
//       }
// 
//       return requestedMeList;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     MonitorElementPtrList ModuleMeInfo::getSubscribedMeList(int clientID) const
//     {
//       MonitorElementPtrList meList;
// 
//       for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         LOG4CXX_DEBUG( dqmMainLogger , "getSubscribedMeList(), me : " << iter->first );
// 
//         if( iter->second->m_clientList.find(clientID) != iter->second->m_clientList.end() )
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "Client " << clientID << " subscribed to it !" );
// 
//           if( NULL != iter->second->m_monitorElement )
//           {
//             LOG4CXX_DEBUG( dqmMainLogger , "Element is not null. Pushed back !" );
//             meList.push_back( iter->second->m_monitorElement );
//           }
//         }
//       }
// 
//       return meList;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     std::pair<size_t, bool> ModuleMeInfo::subscribe(int clientID, const std::string &meName)
//     {
//       MeInfoMap::iterator findIter = m_meInfoMap.find(meName);
// 
//       // if not existing, look if available
//       if(findIter == m_meInfoMap.end())
//       {
//         bool found = false;
// 
//         for(MonitorElementInfoList::iterator iter = m_availableMeList.begin(), endIter = m_availableMeList.end() ;
//             endIter != iter ; ++iter)
//         {
//           std::string fullName = (Path( (*iter)[Key::ME_PATH]) + (*iter)[Key::ME_NAME]).getPath();
// 
//           if(fullName.at(0) != '/')
//             fullName = "/" + fullName;
// 
//           if(fullName == meName)
//           {
//             found = true;
//             break;
//           }
//         }
// 
//         if(found)
//           findIter = m_meInfoMap.insert(MeInfoMap::value_type(meName, new MeInfo())).first;
//         else
//           return std::pair<size_t, bool>( 0 , false );
//       }
// 
//       // add client and return (new) size of client list
//       bool inserted = findIter->second->m_clientList.insert(clientID).second;
//       size_t newSize = findIter->second->m_clientList.size();
// 
//       return std::pair<size_t, bool>( newSize , inserted );
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     std::pair<size_t, bool> ModuleMeInfo::unsubscribe(int clientID, const std::string &meName)
//     {
//       MeInfoMap::iterator findIter = m_meInfoMap.find(meName);
// 
//       if(findIter == m_meInfoMap.end())
//         return std::pair<size_t, bool>( 0 , true );
// 
//       // remove client id and return (new) size of client list
//       bool erased = ( findIter->second->m_clientList.erase(clientID) != 0 );
//       size_t newSize = findIter->second->m_clientList.size();
// 
//       return std::pair<size_t, bool>( newSize , erased );
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool ModuleMeInfo::unsubscribe(int clientID)
//     {
//       bool unsubscribeAtLeastToOne = false;
// 
//       for(MeInfoMap::iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         if(iter->second->m_clientList.erase(clientID))
//           unsubscribeAtLeastToOne = true;
//       }
// 
//       return unsubscribeAtLeastToOne;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     size_t ModuleMeInfo::getNSubscribers(const std::string &meName) const
//     {
//       MeInfoMap::const_iterator findIter = m_meInfoMap.find(meName);
//       return ( ( findIter == m_meInfoMap.end() ) ? 0 : findIter->second->m_clientList.size() );
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     size_t ModuleMeInfo::getNSubscribers() const
//     {
//       std::set<int> clientList;
// 
//       for(MeInfoMap::const_iterator iter = m_meInfoMap.begin(), endIter = m_meInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         clientList.insert(iter->second->m_clientList.begin(), iter->second->m_clientList.end());
//       }
// 
//       return clientList.size();
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     std::set<int> ModuleMeInfo::getSubscribers(const std::string &meName) const
//     {
//       MeInfoMap::const_iterator findIter = m_meInfoMap.find(meName);
// 
//       if(findIter != m_meInfoMap.end())
//         return findIter->second->m_clientList;
// 
//       return std::set<int>();
//     }
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     /** Constructor
//      */
//     ClientInfo::ClientInfo(int clientID) :
// 		    m_clientID(clientID),
// 		    m_updateMode(false),
// 		    m_isModule(false),
// 		    m_moduleName("")
//     {
//       /* nop */
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     ClientInfo::ClientInfo(int clientId, const std::string &moduleName) :
// 		    m_clientID(clientId),
// 		    m_updateMode(false),
// 		    m_isModule(true),
// 		    m_moduleName(moduleName)
//     {
//       /* nop */
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     const std::string &ClientInfo::getModuleName() const
//     {
//       return m_moduleName;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool ClientInfo::isModule() const
//     {
//       return m_isModule;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     int ClientInfo::getClientID() const
//     {
//       return m_clientID;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void ClientInfo::setUpdateMode(bool update)
//     {
//       m_updateMode = update;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool ClientInfo::hasUpdateMode() const
//     {
//       return m_updateMode;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     const std::string MonitorElementCollector::m_emptyBufferStr = "EMPTY";
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     MonitorElementCollector::MonitorElementCollector() :
// 		    m_collectorName("DEFAULT"),
// 		    m_collectorState(STOPPED_STATE),
// 		    m_pMonitorElementNameListRpc(NULL),
// 		    m_pMonitorElementCollectorInfoRpc(NULL),
// 		    m_pInBuffer(NULL)
//     {
//       m_pOutBuffer = new xdrstream::BufferDevice(5*1024*1024);
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     MonitorElementCollector::~MonitorElementCollector()
//     {
//       if(this->isRunning())
//         this->stop();
// 
//       delete m_pOutBuffer;
// 
//       if(m_pInBuffer)
//         delete m_pInBuffer;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     StatusCode MonitorElementCollector::setCollectorName(const std::string &collectorName)
//     {
//       if(isRunning())
//         return STATUS_CODE_NOT_ALLOWED;
// 
//       m_collectorName = collectorName;
// 
//       return STATUS_CODE_SUCCESS;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     const std::string &MonitorElementCollector::getCollectorName() const
//     {
//       return m_collectorName;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     StatusCode MonitorElementCollector::start()
//     {
//       if(isRunning())
//         return STATUS_CODE_SUCCESS;
// 
//       std::string baseName = "DQM4HEP/MonitorElementCollector/" + m_collectorName + "/";
//       std::stringstream ss;
// 
//       ss << baseName << "MONITOR_ELEMENT_NAME_LIST_RPC";
//       m_pMonitorElementNameListRpc = new MonitorElementNameListRpc((char *)ss.str().c_str(), this);
// 
//       ss.str("");
//       ss << baseName << "COLLECTOR_INFO_RPC";
//       m_pMonitorElementCollectorInfoRpc = new MonitorElementCollectorInfoRpc((char *)ss.str().c_str(), this);
// 
//       // from modules
//       ss.str("");
//       ss << baseName << "COLLECT_ME_CMD";
//       m_pCollectMeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
// 
//       ss.str("");
//       ss << baseName << "NOTIFY_WATCHED_ME_SVC";
//       m_pNotifyWatchedMeService = new DimService((char *)ss.str().c_str(), "C",
//           (void*) pMeCollectormptyBuffer, 5);
// 
// 
// 
//       // from clients
//       ss.str("");
//       ss << baseName << "AVAILABLE_ME_CMD";
//       m_pAvailableMeListCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
// 
//       ss.str("");
//       ss << baseName << "QUERY_ME_CMD";
//       m_pMeQueryCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
// 
//       ss.str("");
//       ss << baseName << "SET_UPDATE_MODE_CMD";
//       m_pSetUpdateModeCommand = new DimCommand((char *)ss.str().c_str(), "I", this);
// 
//       ss.str("");
//       ss << baseName << "SUBSCRIBE_CMD";
//       m_pSubscribeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
// 
//       ss.str("");
//       ss << baseName << "UNSUBSCRIBE_CMD";
//       m_pUnsubscribeCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
// 
//       ss.str("");
//       ss << baseName << "SET_SUBSCRIPTION_CMD";
//       m_pSetSubscriptionCommand = new DimCommand((char *)ss.str().c_str(), "C", this);
// 
//       ss.str("");
//       ss << baseName << "STATS";
//       m_pStatisticsService = new StatisticsService(ss.str());
// 
//       ss.str("");
//       ss << baseName << "ME_UPDATE_SVC";
//       m_pMeUpdateService = new DimService((char *)ss.str().c_str(), "C",
//           (void*) pMeCollectormptyBuffer, 5);
// 
//       ss.str("");
//       ss << baseName << "AVAILABLE_ME_SVC";
//       m_pAvailableMeService = new DimService((char *)ss.str().c_str(), "C",
//           (void*) pMeCollectormptyBuffer, 5);
// 
// 
//       m_collectorState = RUNNING_STATE;
// 
//       ss.str("");
//       ss << baseName << "COLLECTOR_STATE_SVC";
//       m_pCollectorStateService = new DimService((char *)ss.str().c_str(), m_collectorState);
// 
//       // for registration on dns ...
//       CoreTool::sleep(std::chrono::seconds(1));
// 
//       // notify server running !
//       LOG4CXX_INFO( dqmMainLogger , "Monitor element collector server started !" );
//       m_pCollectorStateService->updateService(m_collectorState);
// 
//       return STATUS_CODE_SUCCESS;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     StatusCode MonitorElementCollector::stop()
//     {
//       if(!isRunning())
//         return STATUS_CODE_SUCCESS;
// 
//       delete m_pCollectMeCommand;
//       delete m_pAvailableMeListCommand;
//       delete m_pMeQueryCommand;
//       delete m_pSetUpdateModeCommand;
//       delete m_pSubscribeCommand;
//       delete m_pUnsubscribeCommand;
//       delete m_pSetSubscriptionCommand;
// 
//       delete m_pMonitorElementNameListRpc;
//       delete m_pMonitorElementCollectorInfoRpc;
//       delete m_pStatisticsService;
//       delete m_pMeUpdateService;
//       delete m_pNotifyWatchedMeService;
//       delete m_pAvailableMeService;
// 
//       m_collectorState = STOPPED_STATE;
//       m_pCollectorStateService->updateService(m_collectorState);
//       delete m_pCollectorStateService;
// 
//       return STATUS_CODE_SUCCESS;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     State MonitorElementCollector::getState() const
//     {
//       return static_cast<State>(m_collectorState);
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool MonitorElementCollector::isRunning() const
//     {
//       return (m_collectorState == RUNNING_STATE);
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::updateClients(const ClientUpdateMap &clientUpdateMap, bool forceUpdate)
//     {
//       for(ClientUpdateMap::const_iterator iter = clientUpdateMap.begin(), endIter = clientUpdateMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         ClientMap::iterator clientIter = m_clientMap.find(iter->first);
// 
//         if(clientIter == m_clientMap.end())
//         {
//           LOG4CXX_WARN( dqmMainLogger , "Client no " << iter->first << " not registered. Skipping ..." );
//           continue;
//         }
// 
//         if(!clientIter->second.hasUpdateMode() && !forceUpdate)
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "Client no " << iter->first << " is not in update mode. Skipping ..." );
//           continue;
//         }
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Sending updates to client no " << iter->first );
//         this->sendMeUpdate(clientIter->first);
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::commandHandler()
//     {
//       DimCommand *pReceivedCommand = getCommand();
// 
//       LOG4CXX_DEBUG( dqmMainLogger , "Received command : " << pReceivedCommand->getName() );
// 
//       // from modules
//       if(pReceivedCommand == m_pCollectMeCommand)
//       {
//         this->handleMeCollectUpdate(pReceivedCommand);
//       }
//       else if(pReceivedCommand == m_pAvailableMeListCommand)
//       {
//         this->handleAvailableListUpdate(pReceivedCommand);
//       }
//       // from client side
//       else if(pReceivedCommand == m_pMeQueryCommand)
//       {
//         this->handleMeQuery(getClientId(), m_pMeQueryCommand);
//       }
//       else if(pReceivedCommand == m_pSetUpdateModeCommand)
//       {
//         this->handleClientUpdateMode(getClientId(), static_cast<bool>(pReceivedCommand->getInt()));
//       }
//       else if(pReceivedCommand == m_pSubscribeCommand)
//       {
//         this->handleClientSubscription(getClientId(), pReceivedCommand);
//       }
//       else if(pReceivedCommand == m_pUnsubscribeCommand)
//       {
//         this->handleClientUnsubscription(getClientId(), pReceivedCommand);
//       }
//       else if(pReceivedCommand == m_pSetSubscriptionCommand)
//       {
//         this->handleClientRequestList(getClientId(), pReceivedCommand);
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::clientExitHandler()
//     {
//       int clientId = getClientId();
//       this->deregisterClient(clientId);
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleMeCollectUpdate(DimCommand *pCommand)
//     {
//       try
//       {
//         char *pBuffer = static_cast<char *>(pCommand->getData());
//         int bufferSize = pCommand->getSize();
// 
//         if(bufferSize == 0 || NULL == pBuffer)
//         {
//           LOG4CXX_WARN( dqmMainLogger , "Empty buffer, skipping packet ..." );
//           throw StatusCodeException(STATUS_CODE_SUCCESS);
//         }
// 
//         this->configureInBuffer( pBuffer , bufferSize );
// 
//         Publication publication;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , publication ) )
//         {
//           LOG4CXX_ERROR( dqmMainLogger , "Couldn't read publication" );
//           throw StatusCodeException(STATUS_CODE_FAILURE);
//         }
// 
//         if(publication.empty())
//         {
//           LOG4CXX_ERROR( dqmMainLogger , "Empty publication, skipping packet ..." );
//           throw StatusCodeException(STATUS_CODE_SUCCESS);
//         }
// 
//         int nElements = 0;
//         ClientUpdateMap clientUpdateMap;
// 
//         // update the monitor element with the ones received !
//         // build the monitor element list to update for each client
//         for(Publication::iterator iter = publication.begin(), endIter = publication.end() ;
//             endIter != iter ; ++iter)
//         {
//           ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(iter->first);
// 
//           if(findIter == m_moduleMeInfoMap.end())
//             continue;
// 
//           // update monitor elements !
//           for(MonitorElementPtrList::iterator meIter = iter->second.begin(), meEndIter = iter->second.end() ;
//               meEndIter != meIter ; ++meIter)
//           {
//             bool updated = findIter->second->updateMonitorElement(*meIter);
// 
//             nElements++;
// 
//             (*meIter)->setCollectorName(this->getCollectorName());
// 
//             // get the client ids that have subscribed to these elements
//             std::string meFullName = ( (*meIter)->getPath() + (*meIter)->getName() ).getPath();
// 
//             if(meFullName.at(0) != '/')
//               meFullName = "/" + meFullName;
// 
//             LOG4CXX_DEBUG( dqmMainLogger , "meFullName on collect : " << meFullName );
//             std::set<int> clientIdSet = findIter->second->getSubscribers(meFullName);
// 
//             // add the monitor element entry into the update map
//             for(std::set<int>::iterator cliIter = clientIdSet.begin(), cliEndIter = clientIdSet.end() ;
//                 cliEndIter != cliIter ; ++cliIter)
//             {
//               clientUpdateMap[*cliIter].insert(*meIter);
//             }
//           }
//         }
// 
//         m_pStatisticsService->update(nElements);
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Received n elements : " << nElements << " from " << publication.size() << " modules" );
//         this->updateClients(clientUpdateMap);
//       }
//       catch(StatusCodeException &exception)
//       {
//         LOG4CXX_ERROR( dqmMainLogger , "handleMeCollectUpdate(): Exception caught : " << exception.toString() );
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleAvailableListUpdate(DimCommand *pCommand)
//     {
//       if(!this->isRunning())
//         return;
// 
//       try
//       {
//         dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
//         dqm_uint bufferSize = pCommand->getSize();
// 
//         if(NULL == pBuffer || 0 == bufferSize)
//         {
//           LOG4CXX_WARN( dqmMainLogger , "handleAvailableListUpdate(): invalid buffer");
//           return;
//         }
// 
//         this->configureInBuffer( pBuffer , bufferSize );
// 
//         // read the buffer
//         std::string moduleName;
//         if( xdrstream::XDR_SUCCESS != m_pInBuffer->read( & moduleName ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "handleAvailableListUpdate(): module name = " << moduleName );
// 
//         if(moduleName.empty())
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         MonitorElementInfoList availableMeList;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , availableMeList ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         // register client, even if maybe already registered
//         bool newClient = this->registerClient(getClientId(), moduleName);
// 
//         // look for module entry to update
//         ModuleMeInfoMap::iterator findIter = m_moduleMeInfoMap.find(moduleName);
// 
//         // if not found, add the entry
//         if(findIter == m_moduleMeInfoMap.end())
//           findIter = m_moduleMeInfoMap.insert(ModuleMeInfoMap::value_type(moduleName, new ModuleMeInfo())).first;
// 
//         // update the entry
//         findIter->second->setAvailableMeList(availableMeList);
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Received " << availableMeList.size() << " available element from module " << moduleName );
// 
//         if(newClient)
//           this->notifyWatchedMe(moduleName);
// 
//         m_pOutBuffer->reset();
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , availableMeList ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Sending available me list from module '" << moduleName << "' to all clients " );
//         m_pAvailableMeService->updateService((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() );
//       }
//       catch(const StatusCodeException &exception)
//       {
//         LOG4CXX_ERROR( dqmMainLogger , "handleAvailableListUpdate(): Exception caught : " << exception.toString() );
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleClientUpdateMode(int clientId, bool updateMode)
//     {
//       ClientMap::iterator findIter = m_clientMap.find(clientId);
// 
//       if(findIter != m_clientMap.end())
//       {
//         if( ! findIter->second.hasUpdateMode() && updateMode)
//         {
//           LOG4CXX_INFO( dqmMainLogger , "Client no " << clientId << " update mode switched ON. Sending updates !" );
//           this->sendMeUpdate(clientId);
//         }
// 
//         LOG4CXX_INFO( dqmMainLogger , "Client no " << clientId << " setting update mode to " << updateMode );
//         findIter->second.setUpdateMode(updateMode);
// 
//         return;
//       }
// 
//       LOG4CXX_WARN( dqmMainLogger , "Client no " << clientId << " not registered !" );
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleClientRequestList(int clientId, DimCommand *pCommand)
//     {
//       if(!this->isRunning())
//         return;
// 
//       try
//       {
//         dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
//         dqm_uint bufferSize = pCommand->getSize();
// 
//         if(NULL == pBuffer || 0 == bufferSize)
//           return;
// 
//         this->registerClient(clientId);
//         this->configureInBuffer( pBuffer , bufferSize );
// 
//         MonitorElementRequest request;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , request ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         std::map<std::string, MonitorElementRequest> moduleRequestList;
// 
//         for(MonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
//             endIter != iter ; ++iter)
//         {
//           ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);
// 
//           if(moduleIter == m_moduleMeInfoMap.end())
//             continue;
// 
//           LOG4CXX_DEBUG( dqmMainLogger , "Found module : " << iter->first );
//           moduleRequestList[ iter->first ].insert(*iter);
//         }
// 
//         for(auto iter = moduleRequestList.begin(), endIter = moduleRequestList.end() ;
//             endIter != iter ; ++iter)
//         {
//           std::string moduleName = iter->first;
//           ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(moduleName);
// 
//           // first unsubscribe to all
//           moduleIter->second->unsubscribe(clientId);
// 
//           // subscribe to all requested elements
//           for(MonitorElementRequest::iterator reqIter = iter->second.begin(), endReqIter = iter->second.end() ;
//               endReqIter != reqIter ; ++reqIter)
//             moduleIter->second->subscribe(clientId, reqIter->second);
// 
//           // notify module of watched elements
//           this->notifyWatchedMe(moduleName);
//         }
//       }
//       catch(const StatusCodeException &exception)
//       {
//         LOG4CXX_ERROR( dqmMainLogger , "Exception caught : " << exception.toString() );
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleMeQuery(int clientId, DimCommand *pCommand)
//     {
//       if(!this->isRunning())
//         return;
// 
//       try
//       {
//         dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
//         dqm_uint bufferSize = pCommand->getSize();
// 
//         if(NULL == pBuffer || 0 == bufferSize)
//           return;
// 
//         this->configureInBuffer( pBuffer , bufferSize );
//         MonitorElementRequest request;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , request ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         // if nothing specified in the request, just send updates
//         if(request.empty())
//         {
//           LOG4CXX_INFO( dqmMainLogger , "Sending me updates from client query" );
//           this->sendMeUpdate(clientId);
//           return;
//         }
// 
//         this->registerClient(clientId);
// 
//         StringSet updateModuleList;
//         Publication monitorElementPublication;
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Request size : " << request.size() );
// 
//         for(MonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
//             endIter != iter ; ++iter)
//         {
//           ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);
// 
//           if(moduleIter == m_moduleMeInfoMap.end())
//             continue;
// 
//           LOG4CXX_DEBUG( dqmMainLogger , "Found module : " << iter->first );
// 
//           // subscribe to me if not done yet
//           if( moduleIter->second->subscribe(clientId, iter->second).second )
//           {
//             LOG4CXX_DEBUG( dqmMainLogger , "New subscription for element : " << iter->second );
//             updateModuleList.insert(iter->first);
//           }
//           else
//           {
//             LOG4CXX_DEBUG( dqmMainLogger , "Element : " << iter->second << " already subscribed !" );
//           }
// 
//           // find the monitor element
//           MonitorElementPtr monitorElement = moduleIter->second->getMonitorElement(iter->second);
// 
//           if(NULL == monitorElement)
//             continue;
// 
//           LOG4CXX_DEBUG( dqmMainLogger , "Element : " << iter->second << " found !" );
//           monitorElementPublication[iter->first].push_back(monitorElement);
//         }
// 
//         for(StringSet::iterator iter = updateModuleList.begin(), endIter = updateModuleList.end() ;
//             endIter != iter ; ++iter)
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "Module " << *iter << " notified to send new me list !" );
//           this->notifyWatchedMe(*iter);
//         }
// 
//         if(monitorElementPublication.empty())
//           return;
// 
//         m_pOutBuffer->reset();
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , monitorElementPublication ) )
//           return;
// 
//         int clientIds[2];
//         clientIds[0] = clientId;
//         clientIds[1] = 0;
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Me update service called (on query) !" );
//         m_pMeUpdateService->selectiveUpdateService((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() , &clientIds[0]);
//       }
//       catch(const StatusCodeException &exception)
//       {
//         LOG4CXX_WARN( dqmMainLogger , "handleMeQuery(): Exception caught : " << exception.toString() );
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleClientSubscription(int clientId, DimCommand *pCommand)
//     {
//       if(!this->isRunning())
//         return;
// 
//       try
//       {
//         dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
//         dqm_uint bufferSize = pCommand->getSize();
// 
//         if(NULL == pBuffer || 0 == bufferSize)
//           return;
// 
//         this->configureInBuffer( pBuffer , bufferSize );
//         MonitorElementRequest request;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , request ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         // if nothing specified in the request, return
//         if(request.empty())
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "No element to subscribe !" );
//           return;
//         }
// 
//         this->registerClient(clientId);
// 
//         StringSet updateModuleList;
// 
//         for(MonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
//             endIter != iter ; ++iter)
//         {
//           ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);
// 
//           if(moduleIter == m_moduleMeInfoMap.end())
//             continue;
// 
//           if( moduleIter->second->subscribe(clientId, iter->second).second )
//           {
//             LOG4CXX_DEBUG( dqmMainLogger , "New subscription for element : " << iter->second );
//             updateModuleList.insert(iter->first);
//           }
//         }
// 
//         for(StringSet::iterator iter = updateModuleList.begin(), endIter = updateModuleList.end() ;
//             endIter != iter ; ++iter)
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "Module " << *iter << " notified to send new me list !" );
//           this->notifyWatchedMe(*iter);
//         }
//       }
//       catch(const StatusCodeException &exception)
//       {
//         LOG4CXX_WARN( dqmMainLogger , "handleClientSubscription(): Exception caught : " << exception.toString() );
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::handleClientUnsubscription(int clientId, DimCommand *pCommand)
//     {
//       if(!this->isRunning())
//         return;
// 
//       try
//       {
//         dqm_char *pBuffer = static_cast<dqm_char *>(pCommand->getData());
//         dqm_uint bufferSize = pCommand->getSize();
// 
//         if(NULL == pBuffer || 0 == bufferSize)
//           return;
// 
//         this->configureInBuffer( pBuffer , bufferSize );
//         MonitorElementRequest request;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pInBuffer , request ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         // if nothing specified in the request, return
//         if(request.empty())
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "No element to unsubscribe !" );
//           return;
//         }
// 
//         this->registerClient(clientId);
// 
//         StringSet updateModuleList;
// 
//         for(MonitorElementRequest::iterator iter = request.begin(), endIter = request.end() ;
//             endIter != iter ; ++iter)
//         {
//           ModuleMeInfoMap::iterator moduleIter = m_moduleMeInfoMap.find(iter->first);
// 
//           if(moduleIter == m_moduleMeInfoMap.end())
//             continue;
// 
//           if( moduleIter->second->unsubscribe(clientId, iter->second).second )
//           {
//             LOG4CXX_DEBUG( dqmMainLogger , "Element un-subscribed : " << iter->second );
//             updateModuleList.insert(iter->first);
//           }
//         }
// 
//         for(StringSet::iterator iter = updateModuleList.begin(), endIter = updateModuleList.end() ;
//             endIter != iter ; ++iter)
//         {
//           LOG4CXX_DEBUG( dqmMainLogger , "Module " << *iter << " notified to send new me list !" );
//           this->notifyWatchedMe(*iter);
//         }
//       }
//       catch(const StatusCodeException &exception)
//       {
//         LOG4CXX_WARN( dqmMainLogger , "handleClientUnsubscription(): Exception caught : " << exception.toString() );
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::sendMeUpdate(int clientId)
//     {
//       if(!this->isRunning())
//         return;
// 
//       this->registerClient(clientId);
// 
//       Publication monitorElementPublication;
//       LOG4CXX_DEBUG( dqmMainLogger , "Building publication to send to client" );
// 
//       for(ModuleMeInfoMap::const_iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         std::string moduleName = iter->first;
// 
//         MonitorElementPtrList subscribedMeList = iter->second->getSubscribedMeList(clientId);
// 
//         if(subscribedMeList.empty())
//           continue;
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Module " << moduleName << ", total me list = " << subscribedMeList.size() );
// 
//         monitorElementPublication.insert(Publication::value_type(moduleName, subscribedMeList));
//       }
// 
//       if(monitorElementPublication.empty())
//       {
//         LOG4CXX_DEBUG( dqmMainLogger , "Empty publication ! Nothing will be sent !" );
//         return;
//       }
// 
//       m_pOutBuffer->reset();
// 
//       if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pOutBuffer , monitorElementPublication ) )
//         return;
// 
//       int clientIds[2];
//       clientIds[0] = clientId;
//       clientIds[1] = 0;
// 
//       LOG4CXX_DEBUG( dqmMainLogger , "Me update service called (on update)!" );
//       m_pMeUpdateService->selectiveUpdateService((void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition() , &clientIds[0]);
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::notifyWatchedMe(const std::string &moduleName)
//     {
//       int clientId = this->getModuleClientID(moduleName);
// 
//       if(0 == clientId)
//         return;
// 
//       LOG4CXX_DEBUG( dqmMainLogger , "Notify watch me begin" );
// 
//       ModuleMeInfoMap::iterator moduleFindIter = m_moduleMeInfoMap.find(moduleName);
// 
//       if(moduleFindIter == m_moduleMeInfoMap.end())
//         return;
// 
//       StringSet watchedMeList = moduleFindIter->second->getSubscribedList();
//       m_pOutBuffer->reset();
// 
//       if( ! XDR_TESTBIT( StreamingHelper::write( m_pOutBuffer , watchedMeList ) , xdrstream::XDR_SUCCESS ) )
//       {
//         LOG4CXX_DEBUG( dqmMainLogger , "Notify watch me. Couldn't write watched list" );
//         return;
//       }
// 
//       int clientIds[2];
//       clientIds[0] = clientId;
//       clientIds[1] = 0;
// 
//       LOG4CXX_DEBUG( dqmMainLogger , "Notify watch me. Client id " << clientId );
// 
//       m_pNotifyWatchedMeService->selectiveUpdateService( (void *) m_pOutBuffer->getBuffer(), m_pOutBuffer->getPosition(), &clientIds[0] );
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool MonitorElementCollector::registerClient(int clientId)
//     {
//       ClientMap::iterator findIter = m_clientMap.find(clientId);
// 
//       if(findIter != m_clientMap.end())
//         return false;
// 
//       // just insert a new client
//       m_clientMap.insert( ClientMap::value_type( clientId, ClientInfo(clientId) ) );
//       DimServer::setClientExitHandler(clientId);
// 
//       return true;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool MonitorElementCollector::registerClient(int clientId, const std::string moduleName)
//     {
//       ClientMap::iterator findIter = m_clientMap.find(clientId);
// 
//       if(findIter != m_clientMap.end())
//         return false;
// 
//       LOG4CXX_DEBUG( dqmMainLogger , "Registering module " << moduleName << " with client id " << clientId );
// 
//       // insert a new client
//       m_clientMap.insert( ClientMap::value_type( clientId, ClientInfo(clientId, moduleName) ) );
// 
//       // create monitor element storage
//       m_moduleMeInfoMap.insert( ModuleMeInfoMap::value_type( moduleName, new ModuleMeInfo() ) );
// 
//       DimServer::setClientExitHandler(clientId);
// 
//       return true;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     bool MonitorElementCollector::deregisterClient(int clientId)
//     {
//       ClientMap::iterator findIter = m_clientMap.find(clientId);
// 
//       if(findIter == m_clientMap.end())
//         return false;
// 
//       DimServer::clearClientExitHandler(clientId);
// 
//       // module client case
//       if(findIter->second.isModule())
//       {
//         std::string moduleName = findIter->second.getModuleName();
// 
//         ModuleMeInfoMap::iterator moduleFindIter = m_moduleMeInfoMap.find(moduleName);
// 
//         if(moduleFindIter != m_moduleMeInfoMap.end())
//         {
//           delete moduleFindIter->second;
//           m_moduleMeInfoMap.erase(moduleFindIter);
//         }
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Deregistering module " << moduleName << " with client id " << clientId );
//       }
//       // monitor element client case
//       else
//       {
//         // unsubscribe to all element that the client subscribed
//         // this will update the list of watched monitor elements
//         // We then have to notify modules that watched elements are not the same
//         for(ModuleMeInfoMap::iterator iter = m_moduleMeInfoMap.begin(), endIter = m_moduleMeInfoMap.end() ;
//             endIter != iter ; ++iter)
//         {
//           // this returns if at least one element has been removed
//           // from the watched list. Use it to trigger update if necessary
//           bool updateService = iter->second->unsubscribe(clientId);
// 
//           if(updateService)
//             this->notifyWatchedMe(iter->first);
//         }
// 
//         LOG4CXX_DEBUG( dqmMainLogger , "Registering me client " << clientId );
//       }
// 
//       // finally remove the client from the map
//       m_clientMap.erase(findIter);
// 
//       return true;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     int MonitorElementCollector::getModuleClientID(const std::string &moduleName) const
//     {
//       for(ClientMap::const_iterator iter = m_clientMap.begin(), endIter = m_clientMap.end() ;
//           endIter != iter ; ++iter)
//       {
//         if( ! iter->second.isModule() )
//           continue;
// 
//         if( iter->second.getModuleName() == moduleName )
//           return iter->first;
//       }
// 
//       return 0;
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollector::configureInBuffer( char *pBuffer , uint32_t bufferSize )
//     {
//       if( ! m_pInBuffer )
//         m_pInBuffer = new xdrstream::BufferDevice( pBuffer , bufferSize , false );
//       else
//         m_pInBuffer->setBuffer( pBuffer , bufferSize , false );
// 
//       m_pInBuffer->setOwner( false );
//     }
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     MonitorElementNameListRpc::MonitorElementNameListRpc(char *rpcName, MonitorElementCollector *pCollector) :
// 		    DimRpc(rpcName, "C", "C"),
// 		    m_pCollector(pCollector)
//     {
//       /* nop */
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementNameListRpc::rpcHandler()
//     {
//       try
//       {
//         if(!m_pCollector->isRunning())
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         dqm_char *pBuffer = static_cast<dqm_char *>(getData());
//         dqm_uint bufferSize = getSize();
// 
//         if(NULL == pBuffer || 0 == bufferSize)
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         m_pCollector->configureInBuffer( pBuffer , bufferSize );
//         MonitorElementListNameRequest request;
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::read( m_pCollector->m_pInBuffer , request ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         // transform module name to lower for easier comparison
//         std::string requestModuleName = request[ Key::MODULE_NAME ];
//         std::string requestMonitorElementName = request[ Key::ME_NAME ];
//         std::string requestMonitorElementType = request[ Key::ME_TYPE ];
// 
//         std::transform(requestModuleName.begin(), requestModuleName.end(), requestModuleName.begin(), ::tolower);
//         std::transform(requestMonitorElementName.begin(), requestMonitorElementName.end(), requestMonitorElementName.begin(), ::tolower);
// 
//         MonitorElementInfoList infoList;
// 
//         // loop over available contents and apply some filter to anwser the client query
//         for(MonitorElementCollector::ModuleMeInfoMap::const_iterator iter = m_pCollector->m_moduleMeInfoMap.begin(),
//             endIter = m_pCollector->m_moduleMeInfoMap.end() ; endIter != iter ; ++iter)
//         {
//           std::string moduleName = iter->first;
//           std::transform(moduleName.begin(), moduleName.end(), moduleName.begin(), ::tolower);
// 
//           // partial and lower case compare of module name
//           if(moduleName.find(requestModuleName) == std::string::npos && !requestModuleName.empty())
//             continue;
// 
//           std::vector<MonitorElementInfo> availableMeList = iter->second->getAvailableMeList();
// 
//           for(std::vector<MonitorElementInfo>::iterator meIter = availableMeList.begin(), meEndIter = availableMeList.end() ;
//               meEndIter != meIter ; ++meIter)
//           {
//             std::string meName = (*meIter)[ Key::ME_NAME ];
//             std::transform(meName.begin(), meName.end(), meName.begin(), ::tolower);
// 
//             std::string path = (*meIter)[ Key::ME_PATH ];
//             std::transform(path.begin(), path.end(), path.begin(), ::tolower);
// 
//             std::string type = (*meIter)[ Key::ME_TYPE ];
// 
//             // partial and lower case compare of me name and
//             // partial and lower case compare of path using me name
//             if(meName.find(requestMonitorElementName) == std::string::npos && !requestMonitorElementName.empty()
//                 && path.find(requestMonitorElementName) == std::string::npos && !requestMonitorElementName.empty())
//               continue;
// 
//             // compare me type
//             if(type != requestMonitorElementType && monitorElementTypeToString(NO_ELEMENT_TYPE) != requestMonitorElementType)
//               continue;
// 
//             infoList.push_back(*meIter);
//           }
//         }
// 
//         // serialize the packet
//         m_pCollector->m_pOutBuffer->reset();
// 
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pCollector->m_pOutBuffer , infoList ) )
//           throw StatusCodeException(STATUS_CODE_FAILURE);
// 
//         LOG4CXX_ERROR( dqmMainLogger , "MonitorElementNameListRpc::rpcHandler() : Sending back request !" );
// 
//         // and set it as data to send back
//         setData((void*) m_pCollector->m_pOutBuffer->getBuffer(), m_pCollector->m_pOutBuffer->getPosition());
//       }
//       catch(StatusCodeException &exception)
//       {
//         LOG4CXX_ERROR( dqmMainLogger , "MonitorElementNameListRpc::rpcHandler() : Exception caught : " << exception.toString() );
//       }
//       catch(...)
//       {
//       }
//     }
// 
//     //-------------------------------------------------------------------------------------------------
//     //-------------------------------------------------------------------------------------------------
// 
//     MonitorElementCollectorInfoRpc::MonitorElementCollectorInfoRpc(char *rpcName, MonitorElementCollector *pCollector) :
// 		    DimRpc(rpcName, "C", "C"),
// 		    m_pCollector(pCollector)
//     {
//       /* nop */
//     }
// 
//     //-------------------------------------------------------------------------------------------------
// 
//     void MonitorElementCollectorInfoRpc::rpcHandler()
//     {
//       try
//       {
//         HostInfo collectorInfo;
//         CoreTool::fillHostInfo(collectorInfo);
// 
//         // serialize the packet
//         m_pCollector->m_pOutBuffer->reset();
//         if( xdrstream::XDR_SUCCESS != StreamingHelper::write( m_pCollector->m_pOutBuffer , collectorInfo ) )
//           return;
// 
//         // and set it as data to send back
//         setData((void*) m_pCollector->m_pOutBuffer->getBuffer(), m_pCollector->m_pOutBuffer->getPosition());
//       }
//       catch(StatusCodeException &exception)
//       {
//       }
//       catch(...)
//       {
//       }
//     }
// 
//   }
// 
// }


